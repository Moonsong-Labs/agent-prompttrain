#!/usr/bin/env bun

/**
 * Aggregate Amazon Bedrock CloudWatch metrics for the last 24 hours (configurable)
 * and estimate cost based on per-million-token pricing.
 *
 * Usage examples:
 *   bun run scripts/aws-bedrock-cost-report.ts --region us-east-1 --model-id anthropic.claude-3-sonnet-20240229-v1:0 \
 *     --input-token-price 3.00 --output-token-price 15.00
 *
 *   bun run scripts/aws-bedrock-cost-report.ts --region us-east-1 \
 *     --model-id anthropic.claude-haiku-4-5:20241022 --pricing-model claude-haiku-4-5
 *
 *   bun run scripts/aws-bedrock-cost-report.ts --list-pricing
 *
 * Required AWS credentials must be available via the usual environment variables,
 * config/credentials file, or an --profile argument.
 */

import {
  CloudWatchClient,
  GetMetricStatisticsCommand,
  ListMetricsCommand,
} from '@aws-sdk/client-cloudwatch'
import { config as loadEnv } from 'dotenv'

loadEnv()

let colorEnabled = process.stdout.isTTY

const ANSI_CODES = {
  reset: '\x1b[0m',
  bold: '\x1b[1m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  green: '\x1b[32m',
  cyan: '\x1b[36m',
  gray: '\x1b[90m',
}

function colorize(value: string, ...codes: string[]): string {
  if (!colorEnabled) {
    return value
  }
  const prefix = codes.join('')
  return `${prefix}${value}${ANSI_CODES.reset}`
}

function stripAnsi(value: string): string {
  return value.replace(/\x1B\[[0-9;]*m/g, '')
}

type TableRow = (string | number)[]

type MetricName =
  | 'CacheReadInputTokenCount'
  | 'CacheWriteInputTokenCount'
  | 'InputTokenCount'
  | 'InvocationLatency'
  | 'Invocations'
  | 'ModelInvocationLogsCloudWatchDeliverySuccess'
  | 'OutputTokenCount'

type MetricStat = 'Sum' | 'Average'

type PriceKey = 'input' | 'output' | 'cacheRead' | 'cacheWrite'

type MetricDefinition = {
  metricName: MetricName
  stat: MetricStat
  unitLabel: string
  shortLabel: string
  description: string
  priceKey?: PriceKey
  cloudWatchUnit?: string
}

const METRICS: readonly MetricDefinition[] = [
  {
    metricName: 'CacheReadInputTokenCount',
    stat: 'Sum',
    unitLabel: 'tokens',
    shortLabel: 'CacheRead',
    description: 'Tokens served from Bedrock cache',
    priceKey: 'cacheRead',
  },
  {
    metricName: 'CacheWriteInputTokenCount',
    stat: 'Sum',
    unitLabel: 'tokens',
    shortLabel: 'CacheWrite',
    description: 'Tokens written to Bedrock cache',
    priceKey: 'cacheWrite',
  },
  {
    metricName: 'InputTokenCount',
    stat: 'Sum',
    unitLabel: 'tokens',
    shortLabel: 'Input',
    description: 'Prompt tokens processed by the model',
    priceKey: 'input',
  },
  {
    metricName: 'OutputTokenCount',
    stat: 'Sum',
    unitLabel: 'tokens',
    shortLabel: 'Output',
    description: 'Completion tokens generated by the model',
    priceKey: 'output',
  },
  {
    metricName: 'Invocations',
    stat: 'Sum',
    unitLabel: 'count',
    shortLabel: 'Invocations',
    description: 'Number of InvokeModel calls',
    cloudWatchUnit: 'Count',
  },
  {
    metricName: 'InvocationClientErrors',
    stat: 'Sum',
    unitLabel: 'count',
    shortLabel: 'ClientErr',
    description: 'Client-side invocation errors',
    cloudWatchUnit: 'Count',
  },
  {
    metricName: 'ModelInvocationLogsCloudWatchDeliverySuccess',
    stat: 'Sum',
    unitLabel: 'count',
    shortLabel: 'LogSuccess',
    description: 'Log deliveries succeeding to CloudWatch',
    cloudWatchUnit: 'Count',
  },
] as const

type ParsedArgs = Record<string, string>

function parseArgs(argv: string[]): ParsedArgs {
  const parsed: ParsedArgs = {}
  for (let i = 2; i < argv.length; i += 1) {
    const raw = argv[i]
    if (!raw.startsWith('--')) {
      continue
    }

    const trimmed = raw.slice(2)
    const equalsIndex = trimmed.indexOf('=')

    if (equalsIndex !== -1) {
      const key = trimmed.slice(0, equalsIndex)
      const value = trimmed.slice(equalsIndex + 1)
      parsed[key] = value
      continue
    }

    const key = trimmed
    const maybeValue = argv[i + 1]
    if (!maybeValue || maybeValue.startsWith('--')) {
      parsed[key] = 'true'
    } else {
      parsed[key] = maybeValue
      i += 1
    }
  }

  return parsed
}

function parseListArg(value: string | undefined): string[] {
  if (!value) {
    return []
  }

  return value
    .split(',')
    .map(token => token.trim())
    .filter(token => token.length > 0)
}

function parseBooleanFlag(value: string | undefined): boolean {
  if (!value) {
    return false
  }

  const normalized = value.toLowerCase()
  return normalized === 'true' || normalized === '1' || normalized === 'yes'
}

type PricingConfig = Partial<Record<PriceKey, number>>

function parsePrice(argName: string, value: string | undefined): number | undefined {
  if (!value) {
    return undefined
  }

  const sanitized = value.replace(/^\$/, '')
  const numeric = Number(sanitized)
  if (Number.isNaN(numeric)) {
    throw new Error(`Invalid numeric value for --${argName}: ${value}`)
  }

  if (numeric < 0) {
    throw new Error(`Pricing for --${argName} must be non-negative`)
  }

  return numeric
}

const TOKENS_PER_MILLION = 1_000_000
const TOKENS_PER_THOUSAND = 1_000

type PricingTier = 'standard' | 'batch'

type TierPricing = {
  inputPerThousand: number
  outputPerThousand: number
}

type RegionKey = 'global' | 'us'

type RegionPricing = {
  standard: TierPricing
  batch?: TierPricing
  cacheReadPerThousand?: number
  cacheWritePerThousand?: number
}

type ModelPricingEntry = {
  alias: string
  displayName: string
  matchers: string[]
  regions: Partial<Record<RegionKey, RegionPricing>>
}

const MODEL_PRICING: readonly ModelPricingEntry[] = [
  {
    alias: 'claude-haiku-4-5',
    displayName: 'Claude Haiku 4.5',
    matchers: ['haiku', '4-5'],
    regions: {
      global: {
        standard: { inputPerThousand: 0.001, outputPerThousand: 0.005 },
        batch: { inputPerThousand: 0.0005, outputPerThousand: 0.0025 },
        cacheReadPerThousand: 0.0001,
        cacheWritePerThousand: 0.00125,
      },
      us: {
        standard: { inputPerThousand: 0.0011, outputPerThousand: 0.0055 },
        batch: { inputPerThousand: 0.00055, outputPerThousand: 0.00275 },
        cacheReadPerThousand: 0.00011,
        cacheWritePerThousand: 0.001375,
      },
    },
  },
  {
    alias: 'claude-sonnet-4-5',
    displayName: 'Claude Sonnet 4.5',
    matchers: ['sonnet', '4-5'],
    regions: {
      global: {
        standard: { inputPerThousand: 0.003, outputPerThousand: 0.015 },
        cacheReadPerThousand: 0.0003,
        cacheWritePerThousand: 0.00375,
      },
      us: {
        standard: { inputPerThousand: 0.0033, outputPerThousand: 0.0165 },
        cacheReadPerThousand: 0.00033,
        cacheWritePerThousand: 0.004125,
      },
    },
  },
  {
    alias: 'claude-sonnet-4-5-long-context',
    displayName: 'Claude Sonnet 4.5 - Long Context',
    matchers: ['sonnet', '4-5', 'long'],
    regions: {
      global: {
        standard: { inputPerThousand: 0.006, outputPerThousand: 0.0225 },
        cacheReadPerThousand: 0.0006,
        cacheWritePerThousand: 0.0075,
      },
      us: {
        standard: { inputPerThousand: 0.0066, outputPerThousand: 0.02475 },
        cacheReadPerThousand: 0.00066,
        cacheWritePerThousand: 0.00825,
      },
    },
  },
  {
    alias: 'claude-sonnet-4',
    displayName: 'Claude Sonnet 4',
    matchers: ['sonnet', '4'],
    regions: {
      global: {
        standard: { inputPerThousand: 0.003, outputPerThousand: 0.015 },
        batch: { inputPerThousand: 0.0015, outputPerThousand: 0.0075 },
        cacheReadPerThousand: 0.0003,
        cacheWritePerThousand: 0.00375,
      },
      us: {
        standard: { inputPerThousand: 0.003, outputPerThousand: 0.015 },
        batch: { inputPerThousand: 0.0015, outputPerThousand: 0.0075 },
        cacheReadPerThousand: 0.0003,
        cacheWritePerThousand: 0.00375,
      },
    },
  },
  {
    alias: 'claude-sonnet-4-long-context',
    displayName: 'Claude Sonnet 4 - Long Context',
    matchers: ['sonnet', '4', 'long'],
    regions: {
      global: {
        standard: { inputPerThousand: 0.006, outputPerThousand: 0.0225 },
        cacheReadPerThousand: 0.0006,
        cacheWritePerThousand: 0.0075,
      },
      us: {
        standard: { inputPerThousand: 0.006, outputPerThousand: 0.0225 },
        cacheReadPerThousand: 0.0006,
        cacheWritePerThousand: 0.0075,
      },
    },
  },
  {
    alias: 'claude-opus-4-1',
    displayName: 'Claude Opus 4.1',
    matchers: ['opus', '4-1'],
    regions: {
      us: {
        standard: { inputPerThousand: 0.015, outputPerThousand: 0.075 },
        cacheReadPerThousand: 0.0015,
        cacheWritePerThousand: 0.01875,
      },
    },
  },
  {
    alias: 'claude-opus-4',
    displayName: 'Claude Opus 4',
    matchers: ['opus', '4'],
    regions: {
      us: {
        standard: { inputPerThousand: 0.015, outputPerThousand: 0.075 },
        cacheReadPerThousand: 0.0015,
        cacheWritePerThousand: 0.01875,
      },
    },
  },
  {
    alias: 'claude-3-7-sonnet',
    displayName: 'Claude 3.7 Sonnet',
    matchers: ['3-7', 'sonnet'],
    regions: {
      us: {
        standard: { inputPerThousand: 0.003, outputPerThousand: 0.015 },
        cacheReadPerThousand: 0.0003,
        cacheWritePerThousand: 0.00375,
      },
    },
  },
  {
    alias: 'claude-3-5-sonnet',
    displayName: 'Claude 3.5 Sonnet',
    matchers: ['3-5', 'sonnet'],
    regions: {
      us: {
        standard: { inputPerThousand: 0.003, outputPerThousand: 0.015 },
        batch: { inputPerThousand: 0.0015, outputPerThousand: 0.0075 },
      },
    },
  },
  {
    alias: 'claude-3-5-haiku',
    displayName: 'Claude 3.5 Haiku',
    matchers: ['3-5', 'haiku'],
    regions: {
      us: {
        standard: { inputPerThousand: 0.0008, outputPerThousand: 0.004 },
        batch: { inputPerThousand: 0.0004, outputPerThousand: 0.002 },
        cacheReadPerThousand: 0.00008,
        cacheWritePerThousand: 0.001,
      },
    },
  },
  {
    alias: 'claude-3-5-sonnet-v2',
    displayName: 'Claude 3.5 Sonnet v2',
    matchers: ['3-5', 'sonnet', 'v2'],
    regions: {
      us: {
        standard: { inputPerThousand: 0.003, outputPerThousand: 0.015 },
        batch: { inputPerThousand: 0.0015, outputPerThousand: 0.0075 },
        cacheReadPerThousand: 0.0003,
        cacheWritePerThousand: 0.00375,
      },
    },
  },
  {
    alias: 'claude-3-opus',
    displayName: 'Claude 3 Opus',
    matchers: ['3-opus'],
    regions: {
      us: {
        standard: { inputPerThousand: 0.015, outputPerThousand: 0.075 },
        batch: { inputPerThousand: 0.0075, outputPerThousand: 0.0375 },
      },
    },
  },
  {
    alias: 'claude-3-haiku',
    displayName: 'Claude 3 Haiku',
    matchers: ['3-haiku'],
    regions: {
      us: {
        standard: { inputPerThousand: 0.00025, outputPerThousand: 0.00125 },
        batch: { inputPerThousand: 0.000125, outputPerThousand: 0.000625 },
      },
    },
  },
  {
    alias: 'claude-3-sonnet',
    displayName: 'Claude 3 Sonnet',
    matchers: ['3-sonnet'],
    regions: {
      us: {
        standard: { inputPerThousand: 0.003, outputPerThousand: 0.015 },
        batch: { inputPerThousand: 0.0015, outputPerThousand: 0.0075 },
      },
    },
  },
  {
    alias: 'claude-2-1',
    displayName: 'Claude 2.1',
    matchers: ['2-1'],
    regions: {
      us: {
        standard: { inputPerThousand: 0.008, outputPerThousand: 0.024 },
      },
    },
  },
  {
    alias: 'claude-2-0',
    displayName: 'Claude 2.0',
    matchers: ['2-0'],
    regions: {
      us: {
        standard: { inputPerThousand: 0.008, outputPerThousand: 0.024 },
      },
    },
  },
] as const

type ResolvedPricing = {
  config: PricingConfig
  entry: ModelPricingEntry
  tier: PricingTier
  region: RegionKey
}

function toSlug(value: string): string {
  return value
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
}

function perThousandToPerMillion(value: number | undefined): number | undefined {
  return value === undefined ? undefined : (value * TOKENS_PER_MILLION) / TOKENS_PER_THOUSAND
}

function normalizeRegionKey(input?: string): RegionKey | undefined {
  if (!input) {
    return undefined
  }

  const normalized = input.trim().toLowerCase()
  if (normalized === 'global') {
    return 'global'
  }
  if (normalized === 'us' || normalized.startsWith('us-')) {
    return 'us'
  }

  return undefined
}

function inferRegionFromModelId(modelId: string): RegionKey | undefined {
  const prefix = modelId.split('.')[0]?.toLowerCase()
  if (prefix === 'global') {
    return 'global'
  }
  if (prefix === 'us') {
    return 'us'
  }
  return undefined
}

function collectRegionCandidates(...keys: Array<RegionKey | undefined>): RegionKey[] {
  const seen = new Set<RegionKey>()
  const result: RegionKey[] = []
  for (const key of keys) {
    if (!key || seen.has(key)) {
      continue
    }
    seen.add(key)
    result.push(key)
  }
  return result
}

function selectRegionPricing(
  entry: ModelPricingEntry,
  regionCandidates: RegionKey[]
): { region: RegionKey; pricing: RegionPricing } | undefined {
  const tried = new Set<RegionKey>()

  for (const candidate of regionCandidates) {
    if (tried.has(candidate)) {
      continue
    }
    tried.add(candidate)
    const pricing = entry.regions[candidate]
    if (pricing) {
      return { region: candidate, pricing }
    }
  }

  for (const fallback of ['global', 'us'] as RegionKey[]) {
    if (tried.has(fallback)) {
      continue
    }
    const pricing = entry.regions[fallback]
    if (pricing) {
      return { region: fallback, pricing }
    }
  }

  return undefined
}

function resolveModelPricing(
  modelId: string,
  aliasOverride: string | undefined,
  tier: PricingTier,
  regionCandidates: RegionKey[]
): ResolvedPricing | undefined {
  const normalizedAlias = aliasOverride ? toSlug(aliasOverride) : undefined
  const sluggedId = toSlug(modelId)

  let matchedEntry: ModelPricingEntry | undefined

  if (normalizedAlias) {
    matchedEntry = MODEL_PRICING.find(entry => entry.alias === normalizedAlias)
    if (!matchedEntry) {
      throw new Error(
        `Unknown pricing model alias "${aliasOverride}". Run with --list-pricing to see supported aliases.`
      )
    }
  } else {
    matchedEntry = MODEL_PRICING.find(entry =>
      entry.matchers.every(matcher => sluggedId.includes(matcher))
    )
  }

  if (!matchedEntry) {
    return undefined
  }

  let tierToUse: PricingTier = tier
  const regionSelection = selectRegionPricing(matchedEntry, regionCandidates)
  if (!regionSelection) {
    return undefined
  }

  const { region, pricing } = regionSelection

  if (tier === 'batch' && !pricing.batch) {
    console.warn(
      `Batch pricing not available for ${matchedEntry.displayName} in region ${region}; falling back to standard tier.`
    )
    tierToUse = 'standard'
  }

  const tierPricing = tierToUse === 'batch' && pricing.batch ? pricing.batch : pricing.standard

  const config: PricingConfig = {
    input: perThousandToPerMillion(tierPricing.inputPerThousand),
    output: perThousandToPerMillion(tierPricing.outputPerThousand),
    cacheRead: perThousandToPerMillion(pricing.cacheReadPerThousand),
    cacheWrite: perThousandToPerMillion(pricing.cacheWritePerThousand),
  }

  return {
    config,
    entry: matchedEntry,
    tier: tierToUse,
    region,
  }
}

type MetricAggregation = {
  definition: MetricDefinition
  total: number
  datapointCount: number
  average?: number
  sampleCount?: number
  estimatedCost?: number
}

type ModelReport = {
  modelId: string
  pricingSource?: string
  aggregations: MetricAggregation[]
  totalEstimatedCost: number
}

type PricingResolutionOutcome = {
  pricing: PricingConfig
  pricingSource?: string
  resolved?: ResolvedPricing
  region?: RegionKey
}

type Dimension = {
  Name: string
  Value: string
}

type DimensionFilters = {
  inferenceType?: string
  operation?: string
}

const numberFormatter = new Intl.NumberFormat('en-US', {
  maximumFractionDigits: 2,
})

const currencyFormatter = new Intl.NumberFormat('en-US', {
  style: 'currency',
  currency: 'USD',
  maximumFractionDigits: 4,
})

function pad(value: string, length: number): string {
  const rawLength = stripAnsi(value).length
  if (rawLength >= length) {
    return value
  }
  return `${value}${' '.repeat(length - rawLength)}`
}

function formatTable(rows: TableRow[]): string {
  if (rows.length === 0) {
    return ''
  }

  const stringRows = rows.map(row => row.map(cell => String(cell ?? '')))
  const columnCount = stringRows[0].length

  const columnWidths = Array.from({ length: columnCount }, (_, columnIndex) => {
    let width = 0
    for (const row of stringRows) {
      const cell = row[columnIndex]
      const lines = cell.split('\n')
      for (const line of lines) {
        width = Math.max(width, stripAnsi(line).length)
      }
    }
    return width
  })

  const separator = `+${columnWidths.map(width => '-'.repeat(width + 2)).join('+')}+`
  const renderedLines: string[] = [separator]

  for (let rowIndex = 0; rowIndex < stringRows.length; rowIndex += 1) {
    const row = stringRows[rowIndex]
    const splitCells = row.map((cell, columnIndex) => {
      const lines = cell.split('\n')
      if (columnIndex === columnCount - 1 && lines.length > 1) {
        const countLine = lines[0]
        const costLine = ` ${lines[1]}`
        return [countLine, costLine, ...lines.slice(2)]
      }
      return lines
    })

    const maxLines = Math.max(...splitCells.map(lines => lines.length))

    for (let lineIndex = 0; lineIndex < maxLines; lineIndex += 1) {
      const lineParts: string[] = ['|']
      for (let columnIndex = 0; columnIndex < columnCount; columnIndex += 1) {
        const lines = splitCells[columnIndex]
        const content = lines[lineIndex] ?? ''
        lineParts.push(` ${pad(content, columnWidths[columnIndex])} `)
        lineParts.push('|')
      }
      renderedLines.push(lineParts.join(''))
    }

    renderedLines.push(separator)
  }

  return renderedLines.join('\n')
}

function formatHeaderCell(value: string): string {
  return colorize(value, ANSI_CODES.bold, ANSI_CODES.cyan)
}

function formatCost(value: number | undefined): string {
  if (value === undefined) {
    return ''
  }
  const formatted = currencyFormatter.format(value)
  if (!colorEnabled) {
    return formatted
  }
  if (value >= 10) {
    return colorize(formatted, ANSI_CODES.bold, ANSI_CODES.red)
  }
  if (value >= 1) {
    return colorize(formatted, ANSI_CODES.yellow)
  }
  if (value > 0) {
    return colorize(formatted, ANSI_CODES.green)
  }
  return colorize(formatted, ANSI_CODES.gray)
}

async function collectMetric(
  client: CloudWatchClient,
  definition: MetricDefinition,
  dimensionSets: Dimension[][],
  startTime: Date,
  endTime: Date,
  periodInSeconds: number,
  pricePerMillionTokens: number | undefined
): Promise<MetricAggregation> {
  let total = 0
  let weightedLatencySum = 0
  let totalSampleCount = 0
  let datapointCount = 0

  for (const dimensions of dimensionSets) {
    const command = new GetMetricStatisticsCommand({
      Namespace: 'AWS/Bedrock',
      MetricName: definition.metricName,
      Dimensions: dimensions,
      StartTime: startTime,
      EndTime: endTime,
      Period: periodInSeconds,
      Statistics: [definition.stat],
      Unit: definition.cloudWatchUnit,
    })

    const response = await client.send(command)
    const datapoints = response.Datapoints ?? []
    datapointCount += datapoints.length

    for (const datapoint of datapoints) {
      if (definition.stat === 'Sum') {
        total += datapoint.Sum ?? 0
        continue
      }

      if (definition.stat === 'Average') {
        const sampleCount = datapoint.SampleCount ?? 1
        const average = datapoint.Average ?? 0
        weightedLatencySum += average * sampleCount
        totalSampleCount += sampleCount
      }
    }
  }

  let average: number | undefined
  if (definition.stat === 'Average') {
    average = totalSampleCount > 0 ? weightedLatencySum / totalSampleCount : 0
    total = average ?? 0
  }

  let estimatedCost: number | undefined
  if (pricePerMillionTokens !== undefined && definition.priceKey) {
    const pricePerToken = pricePerMillionTokens / TOKENS_PER_MILLION
    estimatedCost = total * pricePerToken
  }

  return {
    definition,
    total,
    datapointCount,
    average,
    sampleCount: totalSampleCount > 0 ? totalSampleCount : undefined,
    estimatedCost,
  }
}

async function discoverModelIds(client: CloudWatchClient): Promise<string[]> {
  const discovered = new Set<string>()
  let nextToken: string | undefined

  do {
    const command = new ListMetricsCommand({
      Namespace: 'AWS/Bedrock',
      Dimensions: [{ Name: 'ModelId' }],
      NextToken: nextToken,
    })

    const response = await client.send(command)
    const metrics = response.Metrics ?? []
    for (const metric of metrics) {
      const modelDimension = metric.Dimensions?.find(dimension => dimension.Name === 'ModelId')
      if (modelDimension?.Value) {
        discovered.add(modelDimension.Value)
      }
    }

    nextToken = response.NextToken
  } while (nextToken)

  return Array.from(discovered).sort((a, b) => a.localeCompare(b))
}

function buildPricingForModel(
  modelId: string,
  manualOverrides: PricingConfig,
  pricingAlias: string | undefined,
  pricingTier: PricingTier,
  regionCandidates: RegionKey[]
): PricingResolutionOutcome {
  const outcome: PricingResolutionOutcome = {
    pricing: {},
  }

  const resolved = resolveModelPricing(modelId, pricingAlias, pricingTier, regionCandidates)
  if (resolved) {
    outcome.pricing = { ...resolved.config }
    outcome.resolved = resolved
    outcome.region = resolved.region
  }

  let overrideApplied = false
  for (const key of Object.keys(manualOverrides) as PriceKey[]) {
    const value = manualOverrides[key]
    if (value !== undefined) {
      outcome.pricing[key] = value
      overrideApplied = true
    }
  }

  if (resolved && overrideApplied) {
    outcome.pricingSource = `${resolved.entry.displayName} (${resolved.tier}, ${resolved.region}) + custom overrides`
  } else if (resolved) {
    outcome.pricingSource = `${resolved.entry.displayName} (${resolved.tier}, ${resolved.region})`
  } else if (overrideApplied) {
    outcome.pricingSource = 'custom overrides'
  }

  return outcome
}

function buildFallbackDimensionSet(modelId: string, filters: DimensionFilters): Dimension[] {
  const dimensions: Dimension[] = [{ Name: 'ModelId', Value: modelId }]
  if (filters.inferenceType) {
    dimensions.push({ Name: 'InferenceType', Value: filters.inferenceType })
  }
  if (filters.operation) {
    dimensions.push({ Name: 'Operation', Value: filters.operation })
  }
  return dimensions
}

function dimensionKey(dimensions: Dimension[]): string {
  return dimensions
    .slice()
    .sort((a, b) => a.Name.localeCompare(b.Name))
    .map(dimension => `${dimension.Name}:${dimension.Value}`)
    .join('|')
}

async function resolveDimensionSetsForMetric(
  client: CloudWatchClient,
  metricName: MetricName,
  modelId: string,
  filters: DimensionFilters
): Promise<Dimension[][]> {
  const uniqueSets = new Map<string, Dimension[]>()
  let nextToken: string | undefined

  do {
    const command = new ListMetricsCommand({
      Namespace: 'AWS/Bedrock',
      MetricName: metricName,
      Dimensions: [{ Name: 'ModelId', Value: modelId }],
      NextToken: nextToken,
    })

    const response = await client.send(command)
    const metrics = response.Metrics ?? []

    for (const metric of metrics) {
      const dimensions = (metric.Dimensions ?? [])
        .filter(
          dimension => typeof dimension.Name === 'string' && typeof dimension.Value === 'string'
        )
        .map(dimension => ({ Name: dimension.Name as string, Value: dimension.Value as string }))

      const modelDimension = dimensions.find(dimension => dimension.Name === 'ModelId')
      if (!modelDimension || modelDimension.Value !== modelId) {
        continue
      }

      if (filters.inferenceType) {
        const inferenceDimension = dimensions.find(dimension => dimension.Name === 'InferenceType')
        if (!inferenceDimension || inferenceDimension.Value !== filters.inferenceType) {
          continue
        }
      }

      if (filters.operation) {
        const operationDimension = dimensions.find(dimension => dimension.Name === 'Operation')
        if (!operationDimension || operationDimension.Value !== filters.operation) {
          continue
        }
      }

      const key = dimensionKey(dimensions)
      if (!uniqueSets.has(key)) {
        uniqueSets.set(key, dimensions)
      }
    }

    nextToken = response.NextToken
  } while (nextToken)

  if (uniqueSets.size === 0) {
    return [buildFallbackDimensionSet(modelId, filters)]
  }

  return Array.from(uniqueSets.values())
}

async function main() {
  const args = parseArgs(process.argv)

  const disableColor = parseBooleanFlag(args['no-color'])
  const forceColor = parseBooleanFlag(args.color ?? args['force-color'])
  if (forceColor) {
    colorEnabled = true
  } else if (disableColor) {
    colorEnabled = false
  }

  if (args['list-pricing']) {
    console.log('Supported pricing models:')
    MODEL_PRICING.forEach(entry => {
      const regions = Object.keys(entry.regions)
        .map(regionKey => regionKey.toString())
        .join(', ')
      const supportsBatch = Object.values(entry.regions).some(regionPricing => regionPricing?.batch)
      const batchInfo = supportsBatch ? ' (supports --pricing-tier batch)' : ''
      console.log(
        `- ${entry.displayName} [alias: ${entry.alias}] regions: ${regions || 'n/a'}${batchInfo}`
      )
    })
    return
  }

  if (args.profile) {
    process.env.AWS_PROFILE = args.profile
  }

  const region = args.region ?? process.env.AWS_REGION ?? 'us-east-1'
  const pricingRegionArg = args['pricing-region'] ?? process.env.BEDROCK_PRICING_REGION
  const requestedPricingRegion = normalizeRegionKey(pricingRegionArg)
  const awsRegionKey = normalizeRegionKey(region)

  const inferenceType = args['inference-type'] ?? process.env.BEDROCK_INFERENCE_TYPE
  const operation = args.operation ?? process.env.BEDROCK_OPERATION

  const pricingTierArg = (args['pricing-tier'] ?? 'standard').toLowerCase()
  const pricingTier =
    pricingTierArg === 'standard' || pricingTierArg === 'batch'
      ? (pricingTierArg as PricingTier)
      : (() => {
          throw new Error('Invalid --pricing-tier value. Supported values: standard, batch.')
        })()

  const hours = args.hours ? Number(args.hours) : 24
  if (Number.isNaN(hours) || hours <= 0) {
    throw new Error(`Invalid --hours value: ${args.hours}`)
  }

  const period = args.period ? Number(args.period) : 300
  if (Number.isNaN(period) || period <= 0) {
    throw new Error(`Invalid --period value: ${args.period}`)
  }
  if (period % 60 !== 0) {
    throw new Error(`--period must be a positive multiple of 60 seconds. Received: ${period}`)
  }

  const manualOverrides: PricingConfig = {
    input: parsePrice('input-token-price', args['input-token-price']),
    output: parsePrice('output-token-price', args['output-token-price']),
    cacheRead: parsePrice('cache-read-token-price', args['cache-read-token-price']),
    cacheWrite: parsePrice('cache-write-token-price', args['cache-write-token-price']),
  }

  const pricingAlias = args['pricing-model'] ?? process.env.BEDROCK_PRICING_MODEL

  const providedModelIds = parseListArg(args['model-id'] ?? process.env.BEDROCK_MODEL_ID)
  const discoverModels = parseBooleanFlag(args['discover-models']) || providedModelIds.length === 0

  const now = new Date()
  const startTime = new Date(now.getTime() - hours * 60 * 60 * 1000)

  const client = new CloudWatchClient({ region })

  try {
    const modelIdSet = new Set<string>()
    providedModelIds.forEach(id => modelIdSet.add(id))

    if (discoverModels) {
      const discovered = await discoverModelIds(client)
      discovered.forEach(id => modelIdSet.add(id))
    }

    const modelIds = Array.from(modelIdSet).sort((a, b) => a.localeCompare(b))
    if (modelIds.length === 0) {
      throw new Error(
        'No model IDs provided or discovered. Supply --model-id (comma-separated) or run with --discover-models.'
      )
    }

    const reports: ModelReport[] = []
    const dimensionFilters: DimensionFilters = { inferenceType, operation }

    for (const modelId of modelIds) {
      const modelRegionKey = inferRegionFromModelId(modelId)
      const regionCandidates = collectRegionCandidates(
        requestedPricingRegion,
        modelRegionKey,
        awsRegionKey
      )

      const pricingOutcome = buildPricingForModel(
        modelId,
        manualOverrides,
        pricingAlias,
        pricingTier,
        regionCandidates
      )

      if (!pricingOutcome.pricingSource) {
        console.warn(
          `No pricing configuration matched model "${modelId}". Costs will not be computed for this model unless you provide --pricing-model or manual overrides.`
        )
      }

      const aggregations = await Promise.all(
        METRICS.map(async definition => {
          const dimensionSets = await resolveDimensionSetsForMetric(
            client,
            definition,
            modelId,
            dimensionFilters
          )
          return collectMetric(
            client,
            definition,
            dimensionSets,
            startTime,
            now,
            period,
            definition.priceKey ? pricingOutcome.pricing[definition.priceKey] : undefined
          )
        })
      )

      const totalEstimatedCost = aggregations.reduce((acc, aggregation) => {
        return acc + (aggregation.estimatedCost ?? 0)
      }, 0)

      reports.push({
        modelId,
        pricingSource: pricingOutcome.pricingSource,
        aggregations,
        totalEstimatedCost,
      })
    }

    console.log(colorize('=== Amazon Bedrock Metric Summary ===', ANSI_CODES.bold, ANSI_CODES.cyan))
    console.log(`Time Range: ${startTime.toISOString()} -> ${now.toISOString()}`)
    console.log(`Region: ${region}`)
    console.log(`Inference Type filter: ${inferenceType ?? 'all'}`)
    console.log(`Operation filter: ${operation ?? 'all'}`)
    console.log(`Period: ${period} seconds`)
    console.log(`Models analyzed (${reports.length}):`)
    reports.forEach(report => {
      console.log(`  - ${report.modelId}`)
    })
    console.log('')

    let grandTotal = 0
    let pricedModelCount = 0

    const headerRow: TableRow = [
      formatHeaderCell('Model'),
      ...METRICS.map(metric => formatHeaderCell(metric.shortLabel)),
      formatHeaderCell('TotalCost'),
    ]

    const tableRows: TableRow[] = [headerRow]
    const metricTotals = new Map<MetricName, { total: number; cost: number }>()
    METRICS.forEach(metric => {
      metricTotals.set(metric.metricName, { total: 0, cost: 0 })
    })

    for (const report of reports) {
      const metricByName = new Map<MetricName, MetricAggregation>()
      report.aggregations.forEach(aggregation => {
        metricByName.set(aggregation.definition.metricName, aggregation)
      })

      const modelDisplay =
        report.totalEstimatedCost >= 10
          ? colorize(report.modelId, ANSI_CODES.bold, ANSI_CODES.red)
          : report.totalEstimatedCost >= 1
            ? colorize(report.modelId, ANSI_CODES.bold, ANSI_CODES.yellow)
            : report.totalEstimatedCost > 0
              ? colorize(report.modelId, ANSI_CODES.green)
              : report.pricingSource
                ? report.modelId
                : colorize(`${report.modelId}*`, ANSI_CODES.gray)

      const row: TableRow = [modelDisplay]

      for (const metric of METRICS) {
        const aggregation = metricByName.get(metric.metricName)
        if (!aggregation) {
          row.push('')
          continue
        }

        const totals = metricTotals.get(metric.metricName)
        if (totals) {
          totals.total += aggregation.total
          totals.cost += aggregation.estimatedCost ?? 0
        }

        const countValue = numberFormatter.format(aggregation.total)
        let cell = countValue

        if (metric.priceKey && aggregation.estimatedCost !== undefined) {
          const costValue = formatCost(aggregation.estimatedCost)
          cell = `${countValue}\n${costValue}`
        }

        row.push(cell)
      }

      if (report.pricingSource) {
        pricedModelCount += 1
        grandTotal += report.totalEstimatedCost
        row.push(formatCost(report.totalEstimatedCost))
      } else {
        row.push(colorize('--', ANSI_CODES.gray))
      }

      tableRows.push(row)
    }

    const summaryRow: TableRow = [
      colorize('Summary', ANSI_CODES.bold, ANSI_CODES.cyan),
      ...METRICS.map(metric => {
        const totals = metricTotals.get(metric.metricName)
        if (!totals) {
          return ''
        }
        const countValue = numberFormatter.format(totals.total)
        if (metric.priceKey && totals.cost > 0) {
          return `${countValue}\n${formatCost(totals.cost)}`
        }
        return countValue
      }),
      grandTotal > 0 ? ` \n${formatCost(grandTotal)}` : formatCost(grandTotal),
    ]
    tableRows.push(summaryRow)

    console.log(formatTable(tableRows))
    console.log('')

    reports.forEach(report => {
      if (report.pricingSource) {
        console.log(`${report.modelId}: pricing = ${report.pricingSource}`)
      } else {
        console.log(`${report.modelId}: pricing not configured (costs shown as raw counts)`)
      }
    })
    console.log('')

    if (pricedModelCount > 0) {
      console.log(colorize('=== Estimated Cost Summary ===', ANSI_CODES.bold, ANSI_CODES.cyan))
      console.log(`Grand estimated token cost across priced models: ${formatCost(grandTotal)}`)
      if (grandTotal === 0) {
        console.log(
          'Note: All priced models reported zero billable tokens within the selected window.'
        )
      }
    } else {
      console.log(
        'Estimated cost summary omitted: no pricing configuration was available for the analyzed models.'
      )
    }
  } finally {
    client.destroy()
  }
}

main().catch(error => {
  console.error('Failed to aggregate Bedrock metrics.')
  console.error(error)
  process.exitCode = 1
})
